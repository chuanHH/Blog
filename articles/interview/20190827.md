1. iframe的优缺点？

优点：

(1). 解决加载缓慢的第三方内容如图标和广告等的加载问题

(2). iframe无刷新文件上传

(3). iframe跨域通信

缺点：

(1). iframe会阻塞主页面的Onload事件

(2). 无法被一些搜索引擎索引到

(3). 页面会增加服务器的http请求

(4). 会产生很多页面，不容易管理。


2. 请列举几种隐藏元素的方法

(1) visibility: hidden；这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在。

(2) opacity: 0；一个CSS3属性，设置0可以使一个元素完全透明，制作出和visibility一样的效果。与visibility相比，它可以被transition和animate

(3) position: absolute；使元素脱离文档流，处于普通文档之上，给它设置一个很大的left负值定位，使元素定位在可见区域之外。

(4) display: none；元素会变得不可见，并且不会再占用文档的空间。

(5) transform: scale(0)；将一个元素设置为无限小，这个元素将不可见。这个元素原来所在的位置将被保留。

(6) HTML5 hidden attribute；hidden属性的效果和display:none;相同，这个属性用于记录一个元素的状态

(7) height: 0; overflow: hidden；将元素在垂直方向上收缩为0,使元素消失。只要元素没有可见的边框，该技术就可以正常工作。

(8) filter: blur(1000px)；给一个很大的值，从而使这个元素“消失”在页面中



3. 鉴于老有人爱问跨域 我整理一下吧

为什么会有跨域或者什么是跨域

出于浏览器的同源策略限制，浏览器会拒绝跨域请求

严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的

通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向；

通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签；

通常浏览器不允许跨域读操作（Cross-origin reads）。

什么情况才算作跨域

非同源请求，均为跨域。

同源 —— 如果两个页面拥有相同的协议（protocol），端口（port）和主机（host），那么这两个页面就属于同一个源（origin）。

既协议、端口和主机有任何一个不同都算跨域例如:http://www.zcabc.com去发送请求如下的地址

```js
   http://www.zcabc.com/a.html // 不跨域 同源 
   https://www.zcabc.com  // 跨域====协议不同
   http://wwww.zcabc.com:88 //跨域== 端口不同
   http://zcabc.com  // 跨域===主机不同

```
为什么有跨域需求

场景 —— 工程服务化后，不同职责的服务分散在不同的工程中，

往往这些工程的域名是不同的，但一个需求可能需要对应到多个服务，

这时便需要调用不同服务的接口，因此会出现跨域。

如何实现跨域

通常，最常用的跨域方式有以下三种：JSONP、CORS、postMessage

我们先看jsonp

虽然因为同源策略的影响，不能通过XMLHttpRequest请求不同域上的数据（Cross-origin reads）。

但是，在页面上引入不同域上的js脚本文件却是可以的（Cross-origin embedding）。

因此在js文件载入完毕之后，触发回调，可以将需要的data作为参数传入

JSONP的优缺点

优点：兼容性好（兼容低版本IE）

缺点：1.JSONP只支持GET请求； 2.XMLHttpRequest相对于JSONP有着更好的错误处理机制


CORS

CORS 是W3C 推荐的一种新的官方方案，能使服务器支持 XMLHttpRequest 的跨域请求。

CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源。

值得注意的是，通常使用CORS时，异步请求会被分为简单请求和非简单请求。

我们来详细了解一下简单请求和非简单请求吧

简单请求

（1) 请求方法是以下三种方法之一：
    HEAD
    GET
    POST
（2）HTTP的头信息不超出以下几种字段：
    Accept
    Accept-Language
    Content-Language
    Last-Event-ID
    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 

不同时满足上面两个条件，就是非简单请求  

简单请求的时候

浏览器直接发送CORS跨域请求，并在header信息中增加一个Origin字段，表明这是一个跨域的请求

非简单请求的区别是会先发一次预检请求

浏览器先请求服务器，当前网页所在域名是否在服务器许可名单中以及可以使用那些HTTP动词和头信息字段，当客户端得到肯定答复时，浏览器才会正式发出XMLHttpRequest请求

所以可以在抛一个问题 axios和ajax他们的区别？

ok 简单回答一下 默认的content-type是不同的 axios默认的content-type='application'是非简单请求（上面提到过的content-type为三个值）,

而ajax默认的content-type='application/x-www-form-urlencoded',是简单请求，

所以axios请求的时候经常会发送一个Request Method: options的预请求

所以明白了为什么很多时候ajax去请求接口没有跨域但用axios会有？

postMessage

window.postMessage(message,targetOrigin) 方法是html5新引进的特性，

可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，

目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。


4. js中的堆(heap)和栈(stack)

堆 是堆内存的简称。

栈 是栈内存的简称

说到堆栈，我们讲的就是内存的使用和分配

堆是动态分配内存，内存大小不一，也不会自动释放。

栈是自动分配相对固定大小的内存空间，并由系统自动释放
 
javascript的基本类型Undefined、Null、Boolean、Number和String它们都是直接按值存储在栈中的

，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。

javascript中其他类型的数据被称为引用类型的数据 : 如对象(Object)、数组(Array)、函数(Function) …，它们是通过拷贝和new出来的，这样的数据存储于堆中。

其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据

说来也是形象，栈，线性结构，后进先出，便于管理。堆，一个混沌，杂乱无章，方便存储和开辟内存空间

堆与栈的大小

程序运行时，每个线程分配一个栈，每个进程分配一个堆，也就是说，栈是线程独占的，堆是线程共用的。

此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。所以这里只看stack的大小限制。

stack overflow（栈溢出）

因为stack是有限制的，而且stack超出浏览器的规定的栈限制时就会报stack overflow。

一般情况下不会出现这种情况，因为js语言有他自己的GC机制，而出现这种情况一般是js的死循环或者没有正确的停止递归造成的，可以通过调试去追踪stack。


5. js中的执行上下文和执行栈

执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。

每当 Javascript 代码在运行的时候，它都是在执行上下文中运行

JavaScript 中有三种执行上下文类型。

全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。

它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。

一个程序中只会有一个全局执行上下文。

函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。

每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。

函数上下文可以有任意多个。

每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。

Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文。


执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文

当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。

引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。



总结4,5

javaScript引擎是单线程执行，所有代码都是排队执行。

一开始执行的是全局代码，首先创建全局的执行上下文，然后将该执行上下文压入执行栈中。

每当执行一个函数，就会创建该函数的执行上下文，然后将其压入执行栈的顶部，函数执行完成后，执行上下文从底部退出，等待垃圾回收。

游览器js总是访问执行栈顶层的执行上下文。

全局上下文只有唯一的一个，它在浏览器关闭时出栈
