1. 如何让textarea标签中的内容原格式输出

   (1)使用pre标签是我最开始采用的办法，但是这种方法也有一定的缺陷,
    
   比如说我们在使用的编辑器的时候，换行、Tab、空格都会影响到输出结果

   (2) white-space属性指定元素内的空白怎样处理

   我们可以使用white-space:pre-warp或white-space:pre-line达到我们想要的效果


2. 实现对象的继承

   直接上代码吧

    ```js 
        function A(name, age){  //e3
        this.name = name
        this.age = age
        }
        A.prototype.sayHello = function(){
        console.log('hello'+this.name)
        }
        function B(){
        A.apply(this,arguments)
        }
        B.prototype = A.prototype
        let b1 = new B('hc', 27)
        b1.age
      b1.sayHello()
    ```

   es6就简单啦

    ```js
      class A {
            constructor(name,age){
                this.name = name
                this.age = age
            }
            sayHello(){
                console.log('hello'+this.name)  
            }
        }
        class B extends A{
            constructor(name, age){
                super(name, age)
            }
        }
        let b1 = new B('zj', 25)
        b1.age
        b1.sayHello()
     ```


3. 说下你对柯里化函数(currying)的理解，它有什么运用场景   

   柯里化指的是将一个接受多个参数的函数转为一次只接受一个参数的函数，将已接受的参数保存起来，返回接受剩余参数的新函数，
  
   当传入参数个数之和等于被柯里化的原函数的参数个数，返回计算结果。
   
   这样可以使得函数变成只接受一个参数，返回一个值的状态，降低了编程复杂性

   先举个简单例子

   ```js
    const add = (x, y) => x + y
    // currying 一下
    const curryingAdd =(x) => (y)=> x+y
    add(1,2)
    curryingAdd(1)(2)
   ```

  柯里化的好处

 （1）参数复用 

  举个例子

  ```js
   // 正常正则验证字符串 reg.test(txt)
   // 函数封装后
    function check(reg, txt) {
        return reg.test(txt)
    }

    check(/\d+/g, 'test')       //false
    check(/[a-z]+/g, 'test')    //true

    // Currying后
    function curryingCheck(reg) {
        return function(txt) {
            return reg.test(txt)
        }
    }

    var hasNumber = curryingCheck(/\d+/g)
    var hasLetter = curryingCheck(/[a-z]+/g)

    hasNumber('test1')      // true
    hasNumber('testtest')   // false
    hasLetter('21212')      // false
  ```  

  (2).提前确认

  ```js
    var on = function(element, event, handler) {
    if (document.addEventListener) {
        if (element && event && handler) {
            element.addEventListener(event, handler, false);
        }
    } else {
        if (element && event && handler) {
            element.attachEvent('on' + event, handler);
        }
    }
  }

 var on = (function() {
    if (document.addEventListener) {
        return function(element, event, handler) {
            if (element && event && handler) {
                element.addEventListener(event, handler, false);
            }
        };
     } else {
        return function(element, event, handler) {
            if (element && event && handler) {
                element.attachEvent('on' + event, handler);
            }
        };
    }
  })();
  ```

  我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，
  
  但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，
  
  这样其实就是提前确定了会走哪一个方法，避免每次都进行判断

 (3). 延迟运行 (js中bind的实现我们后面还会讲到)

 ```js
    Function.prototype.bind = function (context) {
    var _this = this
    var args = Array.prototype.slice.call(arguments, 1)
 
    return function() {
        return _this.apply(context, args)
    }
  }
 ```

  自己动手实现

   ```js
    function curry (fn) {
    const ctx = this;
    function inner (...args) {
        if (args.length === fn.length) 
        {
            return fn.call(ctx, ...args);
        }
        return (...innerArgs) => inner.call(ctx, ...args, ...innerArgs);
    }
    return inner;
    }
   ```