1. 如何让textarea标签中的内容原格式输出

  (1)使用<pre>标签是我最开始采用的办法，但是这种方法也有一定的缺陷,
    
  比如说我们在使用的编辑器的时候，换行、Tab、空格都会影响到输出结果

  (2) white-space属性指定元素内的空白怎样处理

  我们可以使用white-space:pre-warp或white-space:pre-line达到我们想要的效果


2. 实现对象的继承

   直接上代码吧

    ```js 
        function A(name, age){  //e3
        this.name = name
        this.age = age
        }
        A.prototype.sayHello = function(){
        console.log('hello'+this.name)
        }
        function B(){
        A.apply(this,arguments)
        }
        B.prototype = A.prototype
        let b1 = new B('hc', 27)
        b1.age
        b1.sayHello()
    ```

    ```js
        //es6就简单啦
        class A {
            constructor(name,age){
                this.name = name
                this.age = age
            }
            sayHello(){
                console.log('hello'+this.name)  
            }
        }
        class B extends A{
            constructor(name, age){
                super(name, age)
            }
        }
        let b1 = new B('zj', 25)
        b1.age
        b1.sayHello()
    ```


3. 说下你对柯里化函数(currying)的理解，它有什么运用场景   

   柯里化指的是将一个接受多个参数的函数转为一次只接受一个参数的函数，将已接受的参数保存起来，返回接受剩余参数的新函数，
  
   当传入参数个数之和等于被柯里化的原函数的参数个数，返回计算结果。
   
   这样可以使得函数变成只接受一个参数，返回一个值的状态，降低了编程复杂性

   先举个简单例子

   ```js
    const add = x => y => x + y
    let add5 = add(5)
    add5(5) // 10
    add(1)(2)
   ```

   自己动手实现

   ```js
    function curry (fn) {
    const ctx = this;
    function inner (...args) {
        if (args.length === fn.length) 
        {
            return fn.call(ctx, ...args);
        }
        return (...innerArgs) => inner.call(ctx, ...args, ...innerArgs);
    }
    return inner;
    }
   ```