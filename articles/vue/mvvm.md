1. mvvm和mvc的区别

   什么是mvc，什么是mvvm

   mvc

   Model View Controller，是模型-视图-控制器的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，
   
   将业务逻辑聚集到一个组件里，在改进和个性化定制界面的及用户交互的时候，不需要重新编写业务逻辑。
   
   mvc用于映射传统的输入、处理、输出功能在一个逻辑的图形用户界面的结构中

   mvc就是类似三层的一种架构，主要采用封装（分层）的思想，来降低耦合度，从而使我们的系统更灵活，扩展性更好

   Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。

   View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。

   Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

   m和v之间是不可以直接交互的，而是通过c去交互,m里一定不能拥有v里面的代码是mvc的前提条件

   mvc的优点

  （1）多个视图共享一个模型，大大提高代码的可重用性。

  （2）三个模块相互独立，改变其中一个不会影响其他两，所以依据这种设计模式能构建良好的松耦合性的组件。

  （3）控制器提高了应用程序的灵活性和可控制性。控制器可以用来连接不同的模型和视图去完成用户的需求，这样控制器可以为构造应用程序提高强有力的手段。

  mvc的缺点

  （1）增加了系统结构和实现的复杂性。
  
       对于简单页面，严格遵循mvc，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。

  （2）视图与控制器过于紧密的连接。

      视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。

  （3）视图对模型数据的低效率访问。

      依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。

  （4）目前，一些高级的界面工具或构造器不支持mvc。

鉴于mvc模式的缺陷（主要就是controller层的不断臃肿），mvvm模式就出现了

mvvm
    MVVM是Model-View-ViewModel的简写。

    即模型-视图-视图模型。【模型】指的是后端传递的数据。【视图】指的是所看到的页面(跟mvc的mv是一样的)。

    【视图模型】mvvm模式的核心，它是连接view和model的桥梁。它有两个方向：一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。
    
    二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。
    
    总结：在MVVM的框架下视图和模型是不能直接通信的。
    
    它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图
    
    的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信

    mvvm模式的优点

   （1）双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。
    
    很好做到数据的一致性，不用担心，在模块的这一块数据是这个值，在另一块就是另一个值了。
    
    所以 MVVM模式有些时候又被称作：model-view-binder模式。

   （2）View的功能进一步的强化，具有控制的部分功能，若想无限增强它的功能，
   
   甚至控制器的全部功几乎都可以迁移到各个View上（不过这样不可取，那样View干了不属于它职责范围的事情）。View可以像控制器一样具有自己的View-Model.

   （3）由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身。不用再为看到庞大的控制器逻辑而发愁了。

   （4）可以对View或ViewController的数据处理部分抽象出来一个函数处理model。这样它们专职页面布局和页面跳转，它们必然更一步的简化。

   mvvm模式的缺点

   （1）数据绑定使得 Bug 很难被调试。
   
     你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。

   （2）一个大的模块中model也会很大，虽然使用方便了也很容易保证了数据的一致性，当时长期持有，不释放内存就造成了花费更多的内存。

   （3）数据双向绑定不利于代码重用。客户端开发最常用的重用是View，但是数据双向绑定技术，让你在一个View都绑定了一个model，不同模块的model都不同。那就不能简单重用View了。 